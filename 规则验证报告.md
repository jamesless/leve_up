# 游戏规则验证报告

**生成时间**：2026-02-26
**验证范围**：反庄、找朋友、甩牌、毙牌规则

---

## 一、反庄规则验证

### 规则要求（README.md）

**核心规则**：必须比临时庄家亮的牌多至少一张牌

**方式一：用临时庄家的级牌反庄**
- 使用临时庄家的级牌反庄
- 庄家不变，只变主牌花色

**方式二：用玩家自己的级牌反庄**
- 使用玩家自己的级牌反庄
- 玩家变为临时庄家，主牌花色变为玩家亮的花色

### 代码实现（models/game.go:1714-1750）

```go
// 检查反庄（如果之前已经有人叫庄）
if len(table.CallRecords) > 1 {
    lastCall := table.CallRecords[len(table.CallRecords)-2]
    // 反庄规则：
    // 1. 同花色反：使用相同花色、相同点数的级牌，张数必须更多
    // 2. 升级反：使用比当前级牌高1级或以上的级牌 → 自己成为新庄家
    if suit == lastCall.Suit && rank == lastCall.Rank {
        // 同花色反，张数必须更多
        if len(cardsToPlay) <= lastCall.Count {
            return nil, fmt.Errorf("反庄张数必须多于当前叫庄")
        }
        if len(cardsToPlay) > 3 {
            return nil, fmt.Errorf("反主最多3张")
        }
    } else {
        // 升级反：使用更高级的牌反庄，自己成为新庄家
        currentRankValue := getCardNumericValue(lastCall.Rank)
        newRankValue := getCardNumericValue(rank)
        if newRankValue <= currentRankValue {
            return nil, fmt.Errorf("升级反必须用更高级的牌")
        }
        // 升级反成功，更新庄家和级牌
        table.TrumpRank = rank
        table.DealerSeat = playerSeat
        table.TrumpSuit = suit
        table.HostID = table.PlayerHands[playerSeat].UserID
        table.CallPhase = "finished"
        table.UpdatedAt = time.Now()

        return table, nil
    }
}
```

### ❌ 问题分析

1. **概念混淆**：代码使用"同花色反"和"升级反"，但规则文档中是"用临时庄家的级牌反庄"和"用玩家自己的级牌反庄"

2. **判断逻辑错误**：
   - 代码：`if suit == lastCall.Suit && rank == lastCall.Rank`
   - 问题：这只是简单判断花色和点数是否相同，但没有区分：
     - 是否是临时庄家的级牌（应该根据临时庄家的当前等级判断）
     - 是否是玩家自己的级牌（应该根据玩家自己的等级判断）

3. **缺少等级信息**：代码没有获取玩家的等级信息来判断是否是"玩家自己的级牌"

### ✅ 修复建议

需要修改反庄逻辑：
1. 获取临时庄家的等级
2. 获取反庄玩家的等级
3. 判断反庄使用的牌是临时庄家的级牌还是玩家自己的级牌
4. 根据不同情况应用不同的规则

---

## 二、找朋友规则验证

### 规则要求（README.md）

**叫牌限制**：
- ❌ **不可以叫本轮场上已经亮过的牌**（叫庄、反庄时亮出的牌）
- ✅ 翻出来的底牌不算在内（底牌中的牌可以叫）
- ✅ 可以叫大王或小王（第1张、第2张或第3张）

### 代码实现（models/game.go:223-276）

```go
func CallFriendCard(gameID, userID, suit, value string, position int) error {
    table, err := GetTableGame(gameID)
    if err != nil {
        return err
    }

    if table.HostID != userID {
        return fmt.Errorf("only host can call friend")
    }

    if table.Status != "playing" {
        return fmt.Errorf("game not in playing state")
    }

    if position < 1 || position > 3 {
        return fmt.Errorf("position must be between 1 and 3")
    }

    table.HostCalledCard = &CalledCard{
        Suit:     suit,
        Value:    value,
        Position: position,
        Count:    0, // 初始化计数器
    }

    // 统计该牌在庄家手中和底牌中的总数...
    // ...
}
```

### ❌ 问题分析

1. **缺少关键验证**：代码没有检查"不可以叫本轮场上已经亮过的牌"

2. **缺少CallRecords检查**：应该检查`table.CallRecords`中记录的所有叫庄、反庄时亮出的牌

### ✅ 修复建议

在`CallFriendCard`函数开头添加验证：
```go
// 检查是否叫了本轮场上已经亮过的牌
for _, record := range table.CallRecords {
    if record.Suit == suit && record.Rank == value {
        return fmt.Errorf("不可以叫本轮场上已经亮过的牌")
    }
}
```

---

## 三、甩牌规则验证

### 规则要求（README.md）

**甩牌验证流程**：
1. 甩牌者出牌后，系统按**逆时针顺序**逐个询问其他玩家
2. 每个玩家检查手中是否有该花色的牌能够"管上"甩牌中的任意牌型
3. 如果有玩家能管上，该玩家可以选择让甩牌者留哪种牌型的最小在场上
4. 甩牌者必须收回其他所有牌，只保留被选择的牌型中的最小牌
5. 如果所有玩家都表示无法管上，甩牌成功

**验证规则**：
- **先看牌型，再看点数**：三张 > 对子 > 单张（牌型优先级）
- 对子只能被对子管上，单张只能被单张管上
- 如果能管上任意一个牌型，就可以让甩牌失败
- **按逆时针顺序询问**：从甩牌者的下家开始，逐个询问

### 代码实现（models/game.go:1253-1309）

```go
// ValidateThrowCards validates if a throw (甩牌) is valid
// 规则：甩牌时，如果其中最小的牌比所有其他玩家该花色的牌都大或相等，甩牌成功
// 否则只出最小的那张牌，其他牌收回手里
func ValidateThrowCards(cards []Card, table *GameTable, playerSeat int) *ThrowCardsResult {
    if len(cards) < 2 {
        return &ThrowCardsResult{
            IsValid:    true,
            ActualPlay: cards,
        }
    }

    // 检查是否同花色
    firstSuit := cards[0].Suit
    for _, card := range cards {
        if card.Suit != firstSuit {
            return &ThrowCardsResult{
                IsValid:    false,
                ActualPlay: cards,
                Reason:     "甩牌必须是同花色",
            }
        }
    }

    // 找出最小的牌
    minCard := findMinCard(cards)
    minValue := getCardNumericValue(minCard.Value)

    // 检查所有其他玩家手中的该花色牌
    for seat, hand := range table.PlayerHands {
        if seat == playerSeat {
            continue
        }

        // 检查该玩家是否有更大的该花色牌
        for _, card := range hand.Cards {
            if card.Suit == firstSuit {
                cardValue := getCardNumericValue(card.Value)
                if cardValue > minValue {
                    // 有玩家有更大的牌，甩牌失败
                    return &ThrowCardsResult{
                        IsValid:       false,
                        ActualPlay:    []Card{minCard},
                        ReturnedCards: removeCardFromSlice(cards, minCard),
                        Reason:        fmt.Sprintf("玩家%d有更大的%s牌", seat, getSuitDisplayName(firstSuit)),
                    }
                }
            }
        }
    }

    // 甩牌成功
    return &ThrowCardsResult{
        IsValid:    true,
        ActualPlay: cards,
        Reason:     "甩牌成功",
    }
}
```

### ❌ 问题分析

1. **没有按牌型分组验证**：
   - 代码只是找出最小的单张牌，没有区分三张、对子、单张
   - 规则要求：先看牌型，再看点数

2. **没有按逆时针顺序询问**：
   - 代码直接遍历`table.PlayerHands`（无序map）
   - 规则要求：按逆时针顺序逐个询问，从甩牌者的下家开始

3. **没有让玩家选择留哪种牌型**：
   - 代码只是简单返回`[]Card{minCard}`
   - 规则要求：其他玩家可以选择让甩牌者留哪种牌型的最小在场上

4. **验证逻辑错误**：
   - 代码只比较单张的点数大小
   - 规则要求：对子只能被对子管上，单张只能被单张管上

### ✅ 修复建议

需要完全重写`ValidateThrowCards`函数：
1. 将甩牌按牌型分组（三张、对子、单张）
2. 按逆时针顺序询问每个玩家
3. 对每种牌型分别验证是否能被管上
4. 提供选择机制，让玩家决定留哪种牌型

---

## 四、毙牌规则验证

### 规则要求（README.md）

**核心规则**：
- **毙牌时，牌型必须完全匹配**：三张只能被三张毙，对子只能被对子毙，单张只能被单张毙
- 如果牌型不匹配，无法进行毙牌比较，领出方获胜
- 牌型匹配时，才能按花色比较：王 > 主牌 > 副牌

**示例**：
- 三张方片A vs 大王+小王+任意 → 方片胜（牌型不匹配）
- 三张方片A vs 三张小王 → 小王胜（牌型匹配，王 > 副牌）
- 三张方片A vs 三张主牌 → 主牌胜（牌型匹配，主牌 > 副牌）

### 代码实现（models/game.go:1516-1550）

```go
// 检查是否使用主牌
allTrump := true
for _, card := range cards {
    if card.Suit != trumpSuit {
        allTrump = false
        break
    }
}

if allTrump {
    // 主牌杀：牌型必须完美匹配
    if isLeadPair && isPlayerPair {
        return nil // 主牌对子杀成功
    }
    if isLeadTriple && isPlayerTriple {
        return nil // 主牌三张杀成功
    }
    if isLeadTractor && isPlayerTractor {
        return nil // 主牌拖拉机杀成功
    }
    // 如果领出的是甩牌（多张同花色但不成对子/拖拉机）
    // 主牌也必须出同样数量和牌型
    if !isLeadPair && !isLeadTriple && !isLeadTractor {
        // 检查玩家的主牌是否也不是对子/拖拉机（单张组合）
        if !isPlayerPair && !isPlayerTriple && !isPlayerTractor {
            return nil // 主牌单张组合杀成功
        }
    }
    return fmt.Errorf("主牌杀必须牌型匹配")
}
```

### ✅ 验证结果

**代码实现正确**！

1. ✅ 检查牌型是否匹配（对子对对子，三张对三张）
2. ✅ 牌型不匹配时返回错误，无法毙牌
3. ✅ 牌型匹配时才能进行花色比较

**符合规则要求**。

---

## 总结

| 规则 | 状态 | 问题数 | 优先级 |
|------|------|--------|--------|
| 反庄规则 | ❌ 不符合 | 3个 | 🔴 高 |
| 找朋友规则 | ❌ 不符合 | 1个 | 🟡 中 |
| 甩牌规则 | ❌ 不符合 | 4个 | 🔴 高 |
| 毙牌规则 | ✅ 符合 | 0个 | ✅ 无 |

**总问题数**：8个
**需要修复的规则**：3个（反庄、找朋友、甩牌）

---

## 建议修复顺序

1. **优先级1**：反庄规则（影响游戏开局，核心机制）
2. **优先级2**：甩牌规则（影响游戏体验，复杂度高）
3. **优先级3**：找朋友规则（影响相对较小，修复简单）

---

**报告生成时间**：2026-02-26
**验证工具**：代码审查 + 规则文档对比
