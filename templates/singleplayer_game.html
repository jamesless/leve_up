<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{.title}}</title>
    <link rel="stylesheet" href="/static/css/style.css">
    <link rel="stylesheet" href="/static/css/game_table.css">
    <link rel="stylesheet" href="/static/css/poker-cards.css">
    <link rel="stylesheet" href="/static/css/wheel-selector.css">
    <style>
        /* Game-specific overrides */
        .playing-card {
            width: var(--card-width);
            height: var(--card-height);
        }

        .my-cards {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 5px;
            padding: 15px;
            min-height: 140px;
        }

        .my-cards .poker-card {
            margin-left: -25px;
        }

        .my-cards .poker-card:first-child {
            margin-left: 0;
        }

        .my-cards .poker-card:hover {
            margin-left: -10px;
            margin-right: 15px;
            z-index: 100;
        }

        .my-cards .poker-card.selected {
            margin-left: -10px;
            margin-right: 15px;
        }

        /* Trick card display */
        .trick-cards-area {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 20px;
            min-height: 130px;
        }

        .trick-card-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .trick-player-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(0, 0, 0, 0.5);
            padding: 4px 8px;
            border-radius: 4px;
        }

        .trick-card-slot .poker-card {
            transform: scale(0.75);
            margin: 0;
            cursor: default;
        }

        .trick-card-slot .poker-card:hover {
            transform: scale(0.75);
        }

        /* Status messages */
        .game-status {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 12px;
            font-size: 18px;
            z-index: 1000;
            animation: fadeIn 0.3s ease-out;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        /* Action buttons */
        .action-buttons {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 25px;
            display: flex;
            justify-content: center;
            gap: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn-action {
            padding: 14px 35px;
            font-size: 16px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .btn-action:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-play {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }

        .btn-play:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
        }

        .btn-hint {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.4);
        }

        .btn-hint:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 152, 0, 0.6);
        }

        /* Selection counter */
        .selection-counter {
            position: fixed;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(76, 175, 80, 0.95);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .selection-counter.show {
            display: block;
        }

/* Trick winner animation */
        .trick-winner-card {
            animation: winnerHighlight 1s ease-out;
        }

        @keyframes winnerHighlight {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            }
            50% {
                box-shadow: 0 0 60px rgba(255, 215, 0, 1);
                transform: scale(1.1);
            }
        }

        /* Player played cards area */
        .player-played-cards {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            padding: 8px;
            min-height: 90px;
            min-width: 70px;
        }

        .player-played-cards .poker-card {
            transform: scale(0.6);
            margin: 0;
            cursor: default;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .player-played-cards .poker-card:hover {
            transform: scale(0.65);
        }

        /* Adjust played cards position for different player positions */
        .player-bottom .player-played-cards {
            margin-top: 10px;
        }

        .player-left .player-played-cards {
            margin-left: 10px;
            flex-direction: column;
        }

        .player-right .player-played-cards {
            margin-right: 10px;
            flex-direction: column;
        }

        .player-top-left .player-played-cards,
        .player-top-right .player-played-cards {
            margin-top: -10px;
        }

        /* Friend card display at top */
        .friend-card-display-top {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
        }

        .friend-info-header {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
            font-weight: bold;
        }

        .friend-label {
            font-size: 14px;
            opacity: 0.9;
        }

        .friend-card-detail {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 12px;
        }

        .friend-suit-name {
            font-size: 14px;
        }

        .friend-card-value {
            font-size: 18px;
            font-weight: bold;
        }

        /* Playable card highlight */
        .poker-card.playable {
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.6), 0 0 30px rgba(76, 175, 80, 0.3);
            border: 2px solid #4CAF50;
        }

        .poker-card.playable::after {
            content: '‚úì';
            position: absolute;
            top: -8px;
            right: -8px;
            background: #4CAF50;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        /* Smooth card merge animation */
        .my-cards .poker-card {
            transition: transform 0.3s ease, margin 0.3s ease;
        }

        @keyframes mergeCards {
            0% {
                margin-left: var(--original-margin);
            }
            100% {
                margin-left: -25px;
            }
        }

        .my-cards.merging .poker-card {
            animation: mergeCards 0.4s ease-out forwards;
        }

        /* Trump card breathing effect */
        .poker-card.trump-card {
            animation: trumpCardBreathing 2s ease-in-out infinite;
            position: relative;
        }

        .poker-card.trump-card::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border-radius: 10px;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FF6347, #FFD700);
            background-size: 400% 400%;
            animation: trumpBorderGlow 3s ease infinite;
            z-index: -1;
            opacity: 0.8;
        }

        .poker-card.trump-card.selected::before {
            opacity: 1;
            animation: trumpBorderGlow 1.5s ease infinite;
        }

        @keyframes trumpCardBreathing {
            0%, 100% {
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.4),
                            0 0 20px rgba(255, 215, 0, 0.3),
                            0 0 30px rgba(255, 215, 0, 0.2);
                transform: translateY(0);
            }
            50% {
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.7),
                            0 0 30px rgba(255, 215, 0, 0.5),
                            0 0 45px rgba(255, 215, 0, 0.3);
                transform: translateY(-3px);
            }
        }

        @keyframes trumpBorderGlow {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        /* Trump card badge */
        .poker-card.trump-card .trump-badge {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #333;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(255, 215, 0, 0.5);
            z-index: 10;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="game-table-container">
        <!-- Player Info Panel (Bottom-Right, Simplified) -->
        <div class="player-info-panel" id="playerInfoPanel">
            <div class="player-name-row">
                <span class="player-name" id="myPlayerName">Êàë</span>
                <span class="player-level" id="myPlayerLevel">2Á∫ß</span>
            </div>
        </div>

        <!-- Top Bar -->
        <div class="top-bar">
            <div class="room-info">
                <span class="room-name">{{.game.Name}}</span>
                <span class="room-id">Âçï‰∫∫Ê®°Âºè</span>
            </div>
            <div class="game-info">
                <span class="level-badge">{{.currentLevel}}Á∫ß</span>
                <span class="round-info" id="roundInfo">Á¨¨1ËΩÆ</span>
                <span class="trump-info" id="trumpInfo">Â∞ÜÁâå: <span id="trumpSuitDisplay">-</span></span>
            </div>
            <button class="btn-leave" onclick="leaveGame()">ËøîÂõûÂ§ßÂéÖ</button>
        </div>

        <!-- Friend Card Display (above game table) -->
        <div class="friend-card-display-above" id="friendCardDisplayAbove" style="display: none; text-align: center; padding: 10px;">
            <div class="friend-info-header">
                <span class="friend-label">ÊúãÂèãÁâå</span>
                <span class="friend-card-detail">
                    <span class="friend-suit-name" id="calledSuitNameAbove">ÈªëÊ°É</span>
                    <span class="friend-card-value" id="calledValueDisplayAbove">A</span>
                </span>
            </div>
        </div>

        <!-- Game Table -->
        <div class="game-table" id="gameTable">
            <!-- Table Center - Played Cards -->
            <div class="table-center">
                <div class="trick-cards-area" id="trickCardsArea">
                    <div class="empty-hint" id="emptyHint">Á≠âÂæÖÂá∫Áâå...</div>
                </div>

                <!-- Friend Card Display (hidden - moved above) -->
                <div class="friend-card-display" id="friendCardDisplay" style="display: none;">
                    <span class="friend-label">ÊúãÂèãÁâå:</span>
                    <div class="called-card">
                        <span class="card-suit" id="calledSuit">‚ô†</span>
                        <span class="card-value" id="calledValue">A</span>
                    </div>
                </div>
            </div>

            <!-- Player Positions (5 players around the table) -->
            <!-- Player 1 - Bottom (Current User) -->
            <div class="player-position player-bottom" data-seat="1" id="player-1">
                <div class="player-played-cards" id="played-cards-1">
                    <!-- Cards played by this player will appear here -->
                </div>
            </div>

            <!-- Player 2 - Left -->
            <div class="player-position player-left" data-seat="2" id="player-2">
                <div class="player-info">
                    <div class="player-avatar">ü§ñ</div>
                    <span class="player-name">AI-2</span>
                    <span class="player-cards-count" id="seat2-count">30Âº†</span>
                    <span id="seat2-friend" class="friend-badge" style="display: none; background: #4caf50; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-left: 5px;">ÊúãÂèã</span>
                </div>
                <div class="player-hand-back">
                    <div class="card-back"></div>
                    <div class="card-back"></div>
                    <div class="card-back"></div>
                </div>
                <div class="player-played-cards" id="played-cards-2">
                    <!-- Cards played by this player will appear here -->
                </div>
            </div>

            <!-- Player 3 - Top Left -->
            <div class="player-position player-top-left" data-seat="3" id="player-3">
                <div class="player-info">
                    <div class="player-avatar">ü§ñ</div>
                    <span class="player-name">AI-3</span>
                    <span class="player-cards-count" id="seat3-count">30Âº†</span>
                    <span id="seat3-friend" class="friend-badge" style="display: none; background: #4caf50; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-left: 5px;">ÊúãÂèã</span>
                </div>
                <div class="player-hand-side">
                    <div class="card-back"></div>
                    <div class="card-back"></div>
                    <div class="card-back"></div>
                </div>
                <div class="player-played-cards" id="played-cards-3">
                    <!-- Cards played by this player will appear here -->
                </div>
            </div>

            <!-- Player 4 - Top Right -->
            <div class="player-position player-top-right" data-seat="4" id="player-4">
                <div class="player-info">
                    <div class="player-avatar">ü§ñ</div>
                    <span class="player-name">AI-4</span>
                    <span class="player-cards-count" id="seat4-count">30Âº†</span>
                    <span id="seat4-friend" class="friend-badge" style="display: none; background: #4caf50; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-left: 5px;">ÊúãÂèã</span>
                </div>
                <div class="player-hand-side">
                    <div class="card-back"></div>
                    <div class="card-back"></div>
                    <div class="card-back"></div>
                </div>
                <div class="player-played-cards" id="played-cards-4">
                    <!-- Cards played by this player will appear here -->
                </div>
            </div>

            <!-- Player 5 - Right -->
            <div class="player-position player-right" data-seat="5" id="player-5">
                <div class="player-info">
                    <div class="player-avatar">ü§ñ</div>
                    <span class="player-name">AI-5</span>
                    <span class="player-cards-count" id="seat5-count">30Âº†</span>
                    <span id="seat5-friend" class="friend-badge" style="display: none; background: #4caf50; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-left: 5px;">ÊúãÂèã</span>
                </div>
                <div class="player-hand-back">
                    <div class="card-back"></div>
                    <div class="card-back"></div>
                    <div class="card-back"></div>
                </div>
                <div class="player-played-cards" id="played-cards-5">
                    <!-- Cards played by this player will appear here -->
                </div>
            </div>
        </div>

        <!-- My Hand (Bottom Player) -->
        <div class="my-hand-section">
            <div class="hand-header">
                <span class="hand-title">ÊàëÁöÑÊâãÁâå (<span id="myCardCount">0</span>Âº†)</span>
                <span class="sort-btn" onclick="sortHand()">üìã Êï¥ÁêÜÊâãÁâå</span>
            </div>
            <div class="my-cards" id="myCards">
                <!-- Cards will be rendered here -->
            </div>
        </div>

        <!-- Selection Counter -->
        <div class="selection-counter" id="selectionCounter">
            Â∑≤ÈÄâÊã© <span id="selectedCount">0</span> Âº†Áâå
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons">
            <button class="btn-action btn-play" id="playBtn" onclick="playSelectedCards()" disabled>Âá∫Áâå</button>
            <button class="btn-action btn-hint" id="hintBtn" onclick="showHint()">üí° ÊèêÁ§∫</button>
        </div>
    </div>

    <script src="/static/js/wheel-selector.js"></script>
    <script>
const GAME_ID = "{{.gameID}}";
        const GAME_DATA_RAW = {{.gameJSON}};
        const MY_HAND_RAW = {{.myHandJSON}};
        {{if .user}}
        const USER_INFO = {
            username: "{{.user.Username}}",
            level: "{{.user.Level}}"
        };
        {{else}}
        const USER_INFO = { username: "Êàë", level: "2" };
        {{end}}
        let GAME_DATA = GAME_DATA_RAW || null;
        let MY_HAND = MY_HAND_RAW && typeof MY_HAND_RAW === 'object' ? MY_HAND_RAW : null;
        let selectedCardIndices = new Set();
        let isProcessing = false;
        let firstSelectedCard = null; // Track first selected card for multi-select mode
        let playableCardIndices = new Set(); // Track which cards can be played together

        // Initialize player info panel
        function initPlayerInfoPanel() {
            if (USER_INFO) {
                document.getElementById('myPlayerName').textContent = USER_INFO.username;
                document.getElementById('myPlayerLevel').textContent = USER_INFO.level + 'Á∫ß';
            }
        }

        // Card symbols mapping
        const suitSymbols = {
            'spades': '‚ô†',
            'hearts': '‚ô•',
            'clubs': '‚ô£',
            'diamonds': '‚ô¶',
            'joker': 'üÉè'
        };

        const suitDisplayNames = {
            'spades': 'ÈªëÊ°É',
            'hearts': 'Á∫¢Ê°É',
            'clubs': 'Ê¢ÖËä±',
            'diamonds': 'ÊñπÁâá',
            'joker': 'Áéã',
            '': 'Êó†'
        };

        const suitColors = {
            'spades': 'black',
            'hearts': 'red',
            'clubs': 'black',
            'diamonds': 'red',
            'joker': 'joker'
        };

        // Initialize game
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize player info panel
            initPlayerInfoPanel();

            if (!GAME_DATA || !MY_HAND) {
                loadGameDataFromAPI();
            } else {
                renderGame();
            }
        });

        async function loadGameDataFromAPI() {
            const token = localStorage.getItem('token');
            if (!token) {
                showStatus('ËØ∑ÂÖàÁôªÂΩï');
                return;
            }

            try {
                const response = await fetch(`/api/game/${GAME_ID}/table`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const result = await response.json();

                if (result.success) {
                    GAME_DATA = result;
                    if (result.myHand) {
                        MY_HAND = result.myHand;
                    }
                    renderGame();
                } else {
                    showStatus('Âä†ËΩΩÊ∏∏ÊàèÂ§±Ë¥•: ' + (result.error || 'Êú™Áü•ÈîôËØØ'));
                }
            } catch (e) {
                console.error('Failed to load game:', e);
                showStatus('ÁΩëÁªúÈîôËØØ');
            }
        }

        function renderGame() {
            // Ê£ÄÊü•Ê∏∏ÊàèÁä∂ÊÄÅ
            if (GAME_DATA.status === 'calling') {
                handleCallingPhase();
                return;
            }

            if (GAME_DATA.status === 'discarding') {
                handleDiscardingPhase();
                return;
            }

            renderMyHand();
            updateDisplay();
            updateSelectionCounter();
            updatePlayerInfoPanel();
        }

        // Â§ÑÁêÜÊä¢Â∫ÑÈò∂ÊÆµ
        function handleCallingPhase() {
            renderMyHand();
            updateDisplay();

            // ÊòæÁ§∫Êä¢Â∫ÑÁïåÈù¢
            showStatus('Ê∏∏ÊàèÂáÜÂ§á‰∏≠ÔºåËØ∑Êä¢Â∫Ñ...');

            // Âçï‰∫∫Ê®°ÂºèËá™Âä®Êä¢Â∫Ñ
            if (GAME_DATA.isSinglePlayer && GAME_DATA.status === 'calling') {
                setTimeout(() => {
                    autoCallForDealer();
                }, 1000);
            }
        }

        // Â§ÑÁêÜÊâ£ÁâåÈò∂ÊÆµ
        function handleDiscardingPhase() {
            renderMyHand();
            updateDisplay();
            updatePlayerInfoPanel();

            // ÊòæÁ§∫Êâ£ÁâåÁïåÈù¢
            showStatus('ËØ∑ÈÄâÊã©7Âº†ÁâåÊâ£ÂõûÂ∫ïÁâåÔºàÂ∫ÑÂÆ∂Ôºâ');
            updateSelectionCounter();

            // Âçï‰∫∫Ê®°ÂºèËá™Âä®Êâ£Áâå
            if (GAME_DATA.isSinglePlayer) {
                setTimeout(() => {
                    autoDiscardBottomCards();
                }, 1000);
            }
        }

        // Ëá™Âä®Êâ£ÁâåÔºàÂçï‰∫∫Ê®°ÂºèÔºâ
        async function autoDiscardBottomCards() {
            try {
                // AIËá™Âä®ÈÄâÊã©7Âº†ÁâåÊâ£ÂõûÂ∫ïÁâåÔºàÈÄâÊã©Èùû‰∏ªÁâåÁöÑÂ∞èÁâåÔºâ
                const myHand = GAME_DATA.myHand;
                if (!myHand || !myHand.Cards) {
                    return;
                }

                // Á≠ñÁï•Ôºö‰ºòÂÖà‰øùÁïôÁ∫ßÁâåÂíå‰∏ªÁâåÔºåÊâ£ÊéâÂÖ∂‰ªñËä±Ëâ≤ÁöÑÂ∞èÁâå
                const trumpSuit = GAME_DATA.trumpSuit;
                const trumpRank = GAME_DATA.currentLevel;

                // ÂØπÁâåËøõË°åÊéíÂ∫èÔºå‰ºòÂÖà‰øùÁïô‰∏ªÁâåÂíåÁ∫ßÁâå
                const cards = myHand.Cards.map((card, index) => ({...card, originalIndex: index}));
                cards.sort((a, b) => {
                    // ‰∏ªÁâå‰ºòÂÖàÁ∫ßÊúÄÈ´ò
                    const aIsTrump = a.Suit === trumpSuit || a.Value === trumpRank;
                    const bIsTrump = b.Suit === trumpSuit || b.Value === trumpRank;
                    if (aIsTrump && !bIsTrump) return 1;
                    if (!aIsTrump && bIsTrump) return -1;

                    // Â§ßÁâå‰ºòÂÖà‰øùÁïô
                    const aValue = getCardValue(a);
                    const bValue = getCardValue(b);
                    return aValue - bValue;
                });

                // ÈÄâÊã©Ââç7Âº†ÔºàÊúÄ‰∏çÈáçË¶ÅÁöÑÁâåÔºâÊù•Êâ£
                const cardsToDiscard = cards.slice(0, 7);
                const cardIndices = cardsToDiscard.map(c => c.originalIndex).sort((a, b) => a - b);
                const cardIndicesStr = cardIndices.join(',');

                const token = localStorage.getItem('token');
                const response = await fetch(`/api/game/${GAME_ID}/discard-bottom`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: new URLSearchParams({
                        cardIndices: cardIndicesStr
                    })
                });

                const result = await response.json();
                if (result.success) {
                    GAME_DATA = result.table;
                    renderGame();
                }
            } catch (e) {
                console.error('Auto discard failed:', e);
            }
        }

        // Ëá™Âä®Êä¢Â∫ÑÔºàÂçï‰∫∫Ê®°ÂºèÔºâ
        async function autoCallForDealer() {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/game/${GAME_ID}/call-dealer`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: new URLSearchParams({
                        suit: 'spades', // ÈªòËÆ§‰ΩøÁî®ÈªëÊ°É
                        cardIndices: '0' // Á¨¨‰∏ÄÂº†Áâå
                    })
                });

                const result = await response.json();
                if (result.success) {
                    GAME_DATA = result.table;
                    // ÊòæÁ§∫ËΩÆÁõòÈÄâÊã©Âô®Âè´ÊúãÂèãÁâå
                    showCallFriendWheel();
                }
            } catch (e) {
                console.error('Auto call dealer failed:', e);
            }
        }

        // ÊòæÁ§∫Âè´ÊúãÂèãÁâåÁöÑËΩÆÁõòÈÄâÊã©Âô®
        function showCallFriendWheel() {
            if (GAME_DATA.hostCalledCard) {
                // Â∑≤ÁªèÂè´Ëøá‰∫Ü
                return;
            }

            // ÊòæÁ§∫ËΩÆÁõòÈÄâÊã©Âô®
            showCallCardWheel({
                allowNT: false,
                possibleRanks: ['A', 'K', 'Q', 'J', '10', '9', '8', '7', '6', '5', '4', '3', '2']
            }).then(selection => {
                // Á°ÆËÆ§ÈÄâÊã©
                callFriendCard(selection.suit, selection.rank);
            }).catch(() => {
                showStatus('ÂèñÊ∂àÂè´Áâå');
            });
        }

        // Âè´ÊúãÂèãÁâå
        async function callFriendCard(suit, value) {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/game/${GAME_ID}/call-friend`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: new URLSearchParams({
                        suit: suit,
                        value: value
                    })
                });

                const result = await response.json();
                if (result.success) {
                    showStatus(`Âè´ÁâåÊàêÂäü: ${suit} ${value}`);
                    // Âà∑Êñ∞Ê∏∏ÊàèÁä∂ÊÄÅ
                    await loadGameDataFromAPI();
                }
            } catch (e) {
                console.error('Call friend card failed:', e);
                showStatus('Âè´ÁâåÂ§±Ë¥•');
            }
        }

        // Update player info panel with friend status
        function updatePlayerInfoPanel() {
            if (!GAME_DATA) return;

            // Update friend status in panel
            const friendStatusRow = document.getElementById('friendStatusRow');
            const friendSeatDisplay = document.getElementById('friendSeatDisplay');
            const friendBadgePanel = document.getElementById('friendBadgePanel');

            if (GAME_DATA.friendRevealed && GAME_DATA.friendSeat) {
                friendStatusRow.style.display = 'flex';
                friendSeatDisplay.textContent = GAME_DATA.friendSeat + 'Âè∑‰Ωç';
            }

            // Show friend badge if current player is the friend
            if (GAME_DATA.friendRevealed && GAME_DATA.friendSeat === 1) {
                friendBadgePanel.classList.add('show');
            }
        }

        function getSuitSymbol(suit) {
            return suitSymbols[suit] || suit;
        }

        function getSuitColor(suit) {
            return suitColors[suit] || 'black';
        }

        function isRedSuit(suit) {
            return suit === 'hearts' || suit === 'diamonds';
        }

        function isFaceCard(value) {
            return ['J', 'Q', 'K', 'A'].includes(value);
        }

function renderMyHand(preserveOrder = false) {
            const container = document.getElementById('myCards');
            document.getElementById('myCardCount').textContent = MY_HAND.cards.length;

            // If preserving order, only remove the played card instead of recreating all
            if (preserveOrder) {
                const currentCardElements = container.querySelectorAll('.poker-card');

                // Build a map of current cards by their data attributes (suit + value)
                const currentCardsMap = new Map();
                currentCardElements.forEach(el => {
                    const suit = el.dataset.suit;
                    const value = el.dataset.value;
                    if (suit && value) {
                        const key = `${suit}-${value}`;
                        currentCardsMap.set(key, el);
                    }
                });

                // Mark cards that are still in hand
                const cardsToRemove = [];
                currentCardsMap.forEach((el, key) => {
                    const [suit, value] = key.split('-');
                    const cardExists = MY_HAND.cards.some(card => card.suit === suit && card.value === value);
                    if (!cardExists) {
                        cardsToRemove.push(el);
                    }
                });

                // Remove cards that are no longer in hand
                cardsToRemove.forEach(cardEl => {
                    // Add fade-out animation before removing
                    cardEl.style.transition = 'opacity 0.2s, transform 0.2s';
                    cardEl.style.opacity = '0';
                    cardEl.style.transform = 'scale(0.8)';
                    setTimeout(() => cardEl.remove(), 200);
                });

                // Update card indices after removal
                setTimeout(() => {
                    const remainingCards = container.querySelectorAll('.poker-card');
                    remainingCards.forEach((cardEl, newIdx) => {
                        cardEl.dataset.index = newIdx;
                        // Update click handler with new index
                        cardEl.onclick = (e) => {
                            e.stopPropagation();
                            toggleCardSelection(newIdx);
                        };
                    });
                }, 200);

                return;
            }

            // Initial render - sort and create all cards
            container.innerHTML = '';

            // Add unique ID to each card for proper tracking
            MY_HAND.cards.forEach((card, idx) => {
                card._id = idx; // Add unique ID
            });

            // Sort cards by suit and value, keeping track of original indices
            const sortedCardsWithIndices = MY_HAND.cards.map((card, idx) => ({card, originalIndex: idx}))
                .sort((a, b) => {
                    const suitOrder = {'spades': 0, 'hearts': 1, 'clubs': 2, 'diamonds': 3, 'joker': 4};
                    if (suitOrder[a.card.suit] !== suitOrder[b.card.suit]) {
                        return suitOrder[a.card.suit] - suitOrder[b.card.suit];
                    }
                    const valueOrder = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14, 'small': 1, 'big': 15};
                    return valueOrder[a.card.value] - valueOrder[b.card.value];
                });

            sortedCardsWithIndices.forEach((item, idx) => {
                const cardEl = createPokerCard(item.card, item.originalIndex);
                cardEl.classList.add('dealing');
                cardEl.style.animationDelay = `${idx * 0.03}s`;
                container.appendChild(cardEl);
            });
        }

        function createPokerCard(card, index) {
            const cardEl = document.createElement('div');
            const color = getSuitColor(card.suit);
            const isRed = isRedSuit(card.suit);
            const isJoker = card.suit === 'joker';
            const isTrump = GAME_DATA.trumpSuit && (card.suit === GAME_DATA.trumpSuit || card.suit === 'joker');

            cardEl.className = `poker-card ${color} ${isJoker ? 'joker-card' : ''} ${isFaceCard(card.value) ? 'face-card' : ''} ${card.value === 'A' ? 'ace' : ''} ${isTrump ? 'trump-card' : ''}`;
            cardEl.dataset.index = index;
            cardEl.dataset.suit = card.suit;
            cardEl.dataset.value = card.value;
            cardEl.onclick = (e) => {
                e.stopPropagation();
                toggleCardSelection(index);
            };

            // Add trump badge if this is a trump card
            if (isTrump && !isJoker) {
                cardEl.setAttribute('data-trump', 'true');
            }

            const symbol = getSuitSymbol(card.suit);
            const displayValue = card.value === 'small' ? 'Â∞èÁéã' : (card.value === 'big' ? 'Â§ßÁéã' : card.value);
            const trumpSuitName = suitDisplayNames[GAME_DATA.trumpSuit] || '';

            if (isJoker) {
                // Joker card design
                cardEl.innerHTML = `
                    <div class="card-face">
                        <div class="card-corner top">
                            <span class="card-corner-value">${displayValue[0]}</span>
                            <span class="card-corner-suit">üÉè</span>
                        </div>
                        <div class="card-center">
                            <span class="card-center-suit">üÉè</span>
                            <span class="joker-label">${displayValue}</span>
                        </div>
                        <div class="card-corner bottom">
                            <span class="card-corner-value">${displayValue[0]}</span>
                            <span class="card-corner-suit">üÉè</span>
                        </div>
                    </div>
                    ${isTrump ? '<span class="trump-badge">‰∏ªÁâå</span>' : ''}
                `;
            } else {
                // Regular card design
                cardEl.innerHTML = `
                    <div class="card-face">
                        <div class="card-corner top">
                            <span class="card-corner-value">${card.value}</span>
                            <span class="card-corner-suit">${symbol}</span>
                        </div>
                        <div class="card-center">
                            <span class="card-center-suit">${symbol}</span>
                            ${isFaceCard(card.value) ? `<span class="card-center-value">${card.value}</span>` : ''}
                        </div>
                        <div class="card-corner bottom">
                            <span class="card-corner-value">${card.value}</span>
                            <span class="card-corner-suit">${symbol}</span>
                        </div>
                    </div>
                    ${isTrump ? `<span class="trump-badge">${trumpSuitName}</span>` : ''}
                `;

                // Add face card special styling
                if (isFaceCard(card.value)) {
                    cardEl.classList.add('face-card');
                }
            }

            if (selectedCardIndices.has(index)) {
                cardEl.classList.add('selected');
            }

            return cardEl;
        }

        function toggleCardSelection(index) {
            if (GAME_DATA.currentPlayer !== 1) {
                showStatus('‰∏çÊòØ‰Ω†ÁöÑÂõûÂêàÔºÅ', 1500);
                return;
            }

            const cardEl = document.querySelector(`[data-index="${index}"]`);
            const clickedCard = MY_HAND.cards[index];
            const isLead = !GAME_DATA.currentTrick || GAME_DATA.currentTrick.length === 0;

            // If no card is selected yet, select this one and find playable cards
            if (selectedCardIndices.size === 0) {
                selectedCardIndices.add(index);
                firstSelectedCard = clickedCard;
                cardEl.classList.add('selected');
                highlightPlayableCards(index, isLead);
                updateSelectionCounter();
                updatePlayButton();
                return;
            }

            // Check if clicked card can be played together with first selected card
            const isFirstCardValue = clickedCard.value === firstSelectedCard.value;
            const isFirstCardSuit = clickedCard.suit === firstSelectedCard.suit;
            
            // For leading: allow same suit cards (for throw) or same value+suit (for pairs/triples)
            const canPlayTogether = isLead 
                ? (isFirstCardSuit || (isFirstCardValue && isFirstCardSuit))
                : (isFirstCardValue && isFirstCardSuit);

            // If clicking the same card, deselect it
            if (selectedCardIndices.has(index)) {
                selectedCardIndices.delete(index);
                cardEl.classList.remove('selected');

                // If no cards left selected, clear everything
                if (selectedCardIndices.size === 0) {
                    firstSelectedCard = null;
                    clearPlayableHighlights();
                }

                updateSelectionCounter();
                updatePlayButton();
                return;
            }

            // If clicking a card that can be played together, add to selection
            if (canPlayTogether) {
                selectedCardIndices.add(index);
                cardEl.classList.add('selected');
                updateSelectionCounter();
                updatePlayButton();
                return;
            }

            // If clicking a different card, start new selection
            // Clear previous selection AND playable highlights
            selectedCardIndices.forEach(idx => {
                const el = document.querySelector(`[data-index="${idx}"]`);
                if (el) el.classList.remove('selected');
            });
            selectedCardIndices.clear();
            // Clear playable highlights BEFORE highlighting new cards
            clearPlayableHighlights();

            // Select new card
            selectedCardIndices.add(index);
            firstSelectedCard = clickedCard;
            cardEl.classList.add('selected');
            highlightPlayableCards(index, isLead);
            updateSelectionCounter();
            updatePlayButton();
        }

        function highlightPlayableCards(selectedIndex, isLead) {
            const selectedCard = MY_HAND.cards[selectedIndex];
            playableCardIndices.clear();

            MY_HAND.cards.forEach((card, idx) => {
                if (idx !== selectedIndex) {
                    const cardEl = document.querySelector(`[data-index="${idx}"]`);
                    
                    if (isLead) {
                        // Leading: highlight cards with same suit (for throw) or same value+suit (for pairs/triples)
                        if (card.suit === selectedCard.suit) {
                            playableCardIndices.add(idx);
                            cardEl.classList.add('playable');
                        }
                    } else {
                        // Following: only highlight cards with same value AND same suit (for pairs/triples)
                        if (card.value === selectedCard.value && card.suit === selectedCard.suit) {
                            playableCardIndices.add(idx);
                            cardEl.classList.add('playable');
                        }
                    }
                }
            });
        }

        function clearPlayableHighlights() {
            document.querySelectorAll('.poker-card.playable').forEach(card => {
                card.classList.remove('playable');
            });
            document.querySelectorAll('.poker-card.disabled').forEach(card => {
                card.classList.remove('disabled');
            });
            playableCardIndices.clear();
        }

        function updateSelectionCounter() {
            const counter = document.getElementById('selectionCounter');
            const count = document.getElementById('selectedCount');
            count.textContent = selectedCardIndices.size;

            if (selectedCardIndices.size > 0) {
                counter.classList.add('show');
            } else {
                counter.classList.remove('show');
            }
        }

        function updatePlayButton() {
            const playBtn = document.getElementById('playBtn');
            playBtn.disabled = selectedCardIndices.size === 0 || isProcessing;

            // Ê†πÊçÆÊ∏∏ÊàèÁä∂ÊÄÅÊõ¥Êñ∞ÊåâÈíÆÊñáÊú¨
            if (GAME_DATA.status === 'discarding') {
                playBtn.textContent = selectedCardIndices.size === 7 ? 'Êâ£Áâå' : `Êâ£Áâå (${selectedCardIndices.size}/7)`;
            } else {
                playBtn.textContent = 'Âá∫Áâå';
            }
        }

        async function playSelectedCards() {
            if (selectedCardIndices.size === 0 || isProcessing) return;

            isProcessing = true;
            document.getElementById('playBtn').disabled = true;

            const token = localStorage.getItem('token');
            const cardIndices = Array.from(selectedCardIndices).sort((a, b) => a - b);

            try {
                let endpoint;
                let body;

                // Ê†πÊçÆÊ∏∏ÊàèÁä∂ÊÄÅÈÄâÊã©‰∏çÂêåÁöÑAPIÁ´ØÁÇπ
                if (GAME_DATA.status === 'discarding') {
                    // Êâ£ÁâåÈò∂ÊÆµ
                    if (cardIndices.length !== 7) {
                        showStatus('ËØ∑ÈÄâÊã©7Âº†ÁâåÊâ£ÂõûÂ∫ïÁâå', 2000);
                        isProcessing = false;
                        updatePlayButton();
                        return;
                    }
                    endpoint = `/api/game/${GAME_ID}/discard-bottom`;
                    body = `cardIndices=${cardIndices.join(',')}`;
                } else {
                    // Âá∫ÁâåÈò∂ÊÆµ
                    endpoint = `/api/game/${GAME_ID}/play`;
                    body = `cardIndices=${cardIndices.join(',')}`;
                }

                // Send all selected card indices to backend
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Authorization': `Bearer ${token}`
                    },
                    body: body
                });

                const result = await response.json();

                if (result.success) {
                    selectedCardIndices.clear();
                    firstSelectedCard = null;
                    clearPlayableHighlights();
                    await refreshGameState();

                    // Check if game ended
                    if (result.gameEnded) {
                        showStatus(`Ê∏∏ÊàèÁªìÊùüÔºÅ${result.winner} Ëé∑ËÉúÔºÅ`, 5000);
                        return;
                    }

                    // If trick complete, show winner
                    if (result.result && result.result.trickComplete) {
                        showStatus(`Êú¨ËΩÆÁªìÊùüÔºÅÁé©ÂÆ∂ ${result.result.trickWinner} Ëé∑ËÉú`, 2000);
                    }

                    // Â¶ÇÊûúÁé∞Âú®ÊòØplayingÁä∂ÊÄÅÔºåÁªßÁª≠AIÂõûÂêà
                    if (GAME_DATA.status === 'playing') {
                        // Small delay to show played card before AI plays
                        await new Promise(resolve => setTimeout(resolve, 500));

                        // AI turns
                        await playAITurns();
                    }
                } else {
                    showStatus(result.error || 'Êìç‰ΩúÂ§±Ë¥•', 2000);
                }
            } catch (e) {
                console.error('Play card error:', e);
                showStatus('ÁΩëÁªúÈîôËØØ', 1500);
            }

            isProcessing = false;
            updatePlayButton();
        }

        async function playAITurns() {
            const token = localStorage.getItem('token');
            let attempts = 0;
            const maxAttempts = 15;

            while (GAME_DATA.currentPlayer !== 1 && attempts < maxAttempts && GAME_DATA.status === 'playing') {
                attempts++;
                await new Promise(resolve => setTimeout(resolve, 800));

                try {
                    const response = await fetch(`/api/game/${GAME_ID}/ai-play`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    const result = await response.json();

                    if (!result.success) {
                        console.error('AI play failed:', result.error);
                        break;
                    }

                    await refreshGameState();
                } catch (e) {
                    console.error('AI play error:', e);
                    break;
                }
            }

            if (GAME_DATA.currentPlayer === 1) {
                showStatus('ËΩÆÂà∞‰Ω†Âá∫Áâå‰∫ÜÔºÅ', 1500);
            }
        }

async function refreshGameState() {
            const token = localStorage.getItem('token');
            try {
                const response = await fetch(`/api/game/${GAME_ID}/table`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                const result = await response.json();
                if (result.success) {
                    Object.assign(GAME_DATA, result);
                    if (result.myHand) {
                        MY_HAND.cards = result.myHand.cards;
                    }

                    // Clear selection and highlights
                    selectedCardIndices.clear();
                    firstSelectedCard = null;
                    clearPlayableHighlights();

                    // Render hand with preserved order (smooth merge effect)
                    renderMyHand(true);

                    updateDisplay();
                    updateSelectionCounter();
                    updatePlayButton();
                }
            } catch (e) {
                console.error('Failed to refresh game state', e);
            }
        }

        function updateDisplay() {
            // Update trump suit
            document.getElementById('trumpSuitDisplay').textContent = suitDisplayNames[GAME_DATA.trumpSuit] || GAME_DATA.trumpSuit || '-';

            // Update AI card counts
            for (let i = 2; i <= 5; i++) {
                const countEl = document.getElementById(`seat${i}-count`);
                const player = GAME_DATA.players.find(p => p.seat === i);
                if (countEl && player) {
                    countEl.textContent = `${player.cardCount || 0}Âº†`;
                }
            }

            // Update friend badges
            for (let i = 1; i <= 5; i++) {
                const badge = document.getElementById(i === 1 ? 'myFriendBadge' : `seat${i}-friend`);
                if (badge) {
                    const isFriend = GAME_DATA.friendRevealed && GAME_DATA.friendSeat === i;
                    badge.style.display = isFriend ? 'inline' : 'none';
                }
            }

// Update called card
            if (GAME_DATA.hostCalledCard) {
                // Show friend card above game table
                const friendAbove = document.getElementById('friendCardDisplayAbove');
                if (friendAbove) {
                    friendAbove.style.display = 'block';
                    const suitNameEl = document.getElementById('calledSuitNameAbove');
                    const valueEl = document.getElementById('calledValueDisplayAbove');
                    if (suitNameEl) suitNameEl.textContent = suitDisplayNames[GAME_DATA.hostCalledCard.suit] || GAME_DATA.hostCalledCard.suit;
                    if (valueEl) valueEl.textContent = GAME_DATA.hostCalledCard.value;
                }

                // Hide old top display (if exists)
                const oldTop = document.getElementById('friendCardDisplayTop');
                if (oldTop) oldTop.style.display = 'none';

                // Hide center display
                const centerDisplay = document.getElementById('friendCardDisplay');
                if (centerDisplay) centerDisplay.style.display = 'none';
            } else {
                // Hide all friend card displays
                const friendAbove = document.getElementById('friendCardDisplayAbove');
                if (friendAbove) friendAbove.style.display = 'none';
                const oldTop = document.getElementById('friendCardDisplayTop');
                if (oldTop) oldTop.style.display = 'none';
                const centerDisplay = document.getElementById('friendCardDisplay');
                if (centerDisplay) centerDisplay.style.display = 'none';
            }

            // Update trick cards
            updateTrickCards();

            // Update play button text based on game status
            updatePlayButton();
        }

        function updateTrickCards() {
            // Clear all player played cards areas
            for (let seat = 1; seat <= 5; seat++) {
                const playedArea = document.getElementById(`played-cards-${seat}`);
                if (playedArea) {
                    playedArea.innerHTML = '';
                }
            }

            if (!GAME_DATA.currentTrick || GAME_DATA.currentTrick.length === 0) {
                return;
            }

            // Group cards by player seat
            const cardsByPlayer = {};
            for (let seat = 1; seat <= 5; seat++) {
                cardsByPlayer[seat] = [];
            }

            // Distribute cards to respective players
            for (const playedCard of GAME_DATA.currentTrick) {
                if (playedCard.seat >= 1 && playedCard.seat <= 5) {
                    cardsByPlayer[playedCard.seat].push(playedCard.card);
                }
            }

            // Render cards in each player's area
            for (let seat = 1; seat <= 5; seat++) {
                const playedArea = document.getElementById(`played-cards-${seat}`);
                if (!playedArea) continue;

                const cards = cardsByPlayer[seat];
                for (const card of cards) {
                    const cardEl = createPokerCard(card, 0);
                    cardEl.onclick = null;
                    playedArea.appendChild(cardEl);
                }
            }
        }

        function sortHand() {
            renderMyHand();
            showStatus('ÊâãÁâåÂ∑≤Êï¥ÁêÜ', 1000);
        }

        function showHint() {
            const myTurn = GAME_DATA.currentPlayer === 1;
            if (!myTurn) {
                showStatus('Á≠âÂæÖÂÖ∂‰ªñÁé©ÂÆ∂Âá∫Áâå...', 2000);
                return;
            }

            showStatus('ÁÇπÂáªÈÄâÊã©Ë¶ÅÂá∫ÁöÑÁâåÔºåÁÑ∂ÂêéÁÇπÂáªÂá∫ÁâåÊåâÈíÆ', 3000);
        }

        function showStatus(message, duration = 2000) {
            const existing = document.querySelector('.game-status');
            if (existing) existing.remove();

            const statusEl = document.createElement('div');
            statusEl.className = 'game-status';
            statusEl.textContent = message;
            document.body.appendChild(statusEl);

            setTimeout(() => statusEl.remove(), duration);
        }

        function leaveGame() {
            if (confirm('Á°ÆÂÆöË¶ÅÁ¶ªÂºÄÊ∏∏ÊàèÂêóÔºü')) {
                window.location.href = '/game';
            }
        }

// Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && GAME_DATA.currentPlayer === 1 && selectedCardIndices.size > 0) {
                playSelectedCards();
            }
            if (e.key === 'Escape') {
                // Clear all selections and highlights
                selectedCardIndices.clear();
                firstSelectedCard = null;
                document.querySelectorAll('.poker-card.selected').forEach(card => {
                    card.classList.remove('selected');
                });
                clearPlayableHighlights();
                updateSelectionCounter();
                updatePlayButton();
            }
        });
    </script>
</body>
</html>
